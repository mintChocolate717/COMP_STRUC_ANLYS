# NOTE: All the Docststrings are generated by ChatGPT. And the CODE is written by me.

import numpy as np
# Set the line width to use more of the screen width
np.set_printoptions(linewidth=300)
import pandas as pd
from typing import Tuple
from sys import argv

def read_nodes_file(filepath: str) -> Tuple[np.ndarray, int, int]:
    """
    Reads a node file and returns a padded numpy array of node coordinates along with the number of nodes and dimensions.

    The node file is expected to have the following format:
      - The first line contains an integer representing the number of dimensions (num_dims).
      - The second line contains an integer representing the number of nodes (num_nodes).
      - Each subsequent line contains whitespace-separated numeric values representing a node's coordinates.
    - The number of values per line should match the number of dimensions.
    
    Parameters:
      filepath (str): The path to the node file.

    Returns:
      Tuple[np.ndarray, int, int]: A tuple containing:
        - padded_nodes (np.ndarray): A numpy array of node coordinates with an extra padded row at the beginning.
        - num_nodes (int): The number of nodes as read from the file.
        - num_dims (int): The number of dimensions as read from the file.

    Raises:
      FileNotFoundError: If the file specified by `filepath` does not exist.
      ValueError: If the first two lines cannot be converted to integers.
    """
   # Read the first two lines manually
    try:
        with open(filepath, 'r') as file:
            num_dims = int(file.readline().strip())
            num_nodes = int(file.readline().strip())
    except FileNotFoundError:
        exit(f"ERROR! File not found at {filepath}")
    except ValueError:
        exit(f"ERROR! First two lines of file at {filepath} should be integers.")    
    
    # Read the rest of the file (starting from the third line)
    node_file = pd.read_csv(filepath, sep=r'\s+', header=None, skiprows=2)
    # Convert to numpy array
    nodes = node_file.to_numpy()
    # Add an extra row to accommodate 1-based indexing
    padded_nodes = np.pad(nodes, ((1,0), (0,0)), 'constant', constant_values=np.nan)

    return padded_nodes, num_nodes, num_dims

def build_global_connectivity(node_mx: np.ndarray, dof_per_node) -> np.ndarray:
    """
    Builds a global connectivity matrix that assigns a unique global degree of freedom (DOF)
    to each local DOF of every node.

    This function takes a node matrix and the number of DOFs per node, then calculates the global
    DOF for each node's local DOF using 1-based indexing. The resulting matrix has the same shape
    as the input node matrix, with each entry filled with the computed global DOF number or NaN where
    not applicable.

    The global DOF is computed as:
        global_DOF = dof_per_node * (node_num - 1) + local_dof
    where:
      - node_num: the node index (starting from 1, assuming the first row is a padding row)
      - local_dof: the local degree of freedom (ranging from 1 to dof_per_node)

    Parameters:
      node_mx (np.ndarray): A numpy array representing nodes. Its shape is used to define the 
                            global connectivity structure.
      dof_per_node (int): The number of degrees of freedom per node.

    Returns:
      np.ndarray: A numpy array of the same shape as `node_mx`, where each valid entry contains the
                  corresponding global DOF number. Cells with no assignment are filled with NaN.

    Notes:
      - The function assumes that `node_mx` uses 1-based indexing for nodes (i.e., index 0 is a dummy
        or padded row). Adjust if using 0-based indexing.
    """
    # Create an array with the same shape as node_mx, filled with NaN,
    # which will hold the global connectivity information.
    global_connectivity = np.full_like(a = node_mx, fill_value= np.nan, dtype=float)
    # Iterate through each node, starting at 1 to skip the padded row for 1-based indexing.
    for node_num in range(1, len(node_mx)): # iterate thru all nodes
        for local_dof in range(1, dof_per_node + 1): # iterate thru all dof components (x, y, ...)
            # Calculate and assign the global DOF for the current NODE and LOCAL DOF.
            global_connectivity[node_num, local_dof] = dof_per_node * (node_num - 1) + local_dof
    
    return global_connectivity

def read_elements_file(filepath: str = 'inputs/elements') -> Tuple[np.ndarray, np.ndarray, int]:
    """
    Reads an elements file and returns the padded elements array, a subset of element nodes, and the total number of elements.

    The expected file format is:
      - The first line contains an integer representing the number of elements.
      - The following lines contain element data with at least three columns. The first three columns are assumed
        to represent the element nodes (e.g., connectivity information).
      
    Parameters:
      filepath (str): Path to the elements file. Defaults to 'inputs/elements'.

    Returns:
      Tuple[np.ndarray, np.ndarray, int]:
        - padded_elements (np.ndarray): The complete elements array with a padded row for 1-based indexing.
        - element_nodes (np.ndarray): A subarray containing the first three columns of the padded elements array.
        - num_elements (int): The number of elements, as specified in the first line of the file.
    """
    try:
        # Read the first line manually to get the number of elements
        with open(filepath, 'r') as file:
            num_elements = int(file.readline().strip())
    except FileNotFoundError:
        exit(f"ERROR! File not found at {filepath}")
    except ValueError:
        exit(f"ERROR! First line of file at {filepath} should be an integer.")
    # Read the rest of the file (starting from the second line)
    element_file = pd.read_csv(filepath, sep=r'\s+', header=None, skiprows=1)
    # Convert the DataFrame to a numpy array
    elements = element_file.to_numpy()
    # Pad the array with an extra row at the top (filled with NaN) to accommodate 1-based indexing
    padded_elements = np.pad(elements, ((1, 0), (0, 0)), 'constant', constant_values=np.nan)
    # Extract the first three columns as element_nodes (assumes that elements have at least 3 columns)
    element_nodes = padded_elements[:, :3]

    return padded_elements, element_nodes, num_elements

def compute_lengths_and_cosines(elements: np.ndarray, nodes: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    """
    Computes the lengths and direction cosines for each element based on node connectivity and coordinates.

    Each element is defined by two node indices stored in columns 1 and 2 of the 'elements' array (ignoring the padded row).
    The corresponding coordinates for these nodes are retrieved from the 'nodes' array, where the first column is also assumed to be a dummy 
    index and actual coordinate data starts from the second column onward.

    The steps performed are:
      1. Extract the first and second node indices for each element from the 'elements' array (skipping the padded row).
      2. Retrieve the coordinates for these nodes from the 'nodes' array (ignoring the dummy index column).
      3. Calculate the displacement (difference) between the coordinates of the two nodes for each element.
      4. Compute the Euclidean norm (length) of each element based on the displacement.
      5. Calculate the direction cosines for each element by dividing the displacement vector by the element length.
      6. Pad the resulting lengths and cosines arrays with an extra row at the top to maintain 1-based indexing.

    Parameters:
      elements (np.ndarray): A 2D numpy array of element connectivity data, where:
                             - Row 0 is a padded dummy row.
                             - Columns 1 and 2 (starting from row 1) contain the first and second node indices respectively.
      nodes (np.ndarray): A 2D numpy array of node coordinates, where:
                          - Row 0 is a padded dummy row.
                          - Columns starting from index 1 contain the coordinate values for each node.

    Returns:
      Tuple[np.ndarray, np.ndarray]:
        - element_lengths (np.ndarray): A 1D numpy array containing the length of each element, padded with a dummy 
          first entry (NaN) for 1-based indexing.
        - element_cosines (np.ndarray): A 2D numpy array containing the direction cosines for each element, padded 
          with an extra first row and column (NaN) for 1-based indexing.
    """
    # Get each element's 1st node indices (skipping the padded row)
    node_1 = elements[1:, 1].astype(int)
    # Get each element's 2nd node indices (skipping the padded row)
    node_2 = elements[1:, 2].astype(int)

    # Retrieve 2D or 3D coordinates for the first nodes (ignoring the dummy first column in nodes)
    node_1_coordinates = nodes[node_1, 1:] # yes this is fancy indexing from NumPy
    # Retrieve 2D or 3D coordinates for the second nodes (ignoring the dummy first column in nodes)
    node_2_coordinates = nodes[node_2, 1:] # again, fancy indexing
    
    # Compute the displacement vector (difference in coordinates) for each element for each dimension (x, y, ..)
    coordinate_displacements = node_2_coordinates - node_1_coordinates

    # Compute the Euclidean norm (length) of each element based on the displacement vector
    element_lengths = np.linalg.norm(coordinate_displacements, axis=1)

    try:
        # Compute the direction cosines for each element
        element_cosines = coordinate_displacements / element_lengths.reshape(len(elements) - 1, 1)
    except ZeroDivisionError:
        exit("ERROR! Division by zero encountered while computing direction cosines.")

    # Pad the lengths and cosines arrays with an extra row to maintain 1-based indexing
    element_lengths = np.pad(element_lengths, (1, 0), 'constant', constant_values=np.nan)
    element_cosines = np.pad(element_cosines, ((1, 0), (1, 0)), 'constant', constant_values=np.nan)

    return element_lengths, element_cosines

def read_forces_file(filepath: str = 'inputs/forces') -> Tuple[np.ndarray, int]:
    """
    Reads a forces file and returns a padded forces array along with the number of force boundary conditions.

    The expected file format is:
      - The first line contains an integer specifying the number of force boundary conditions.
      - The following lines contain force data, where each row corresponds to a force vector or boundary condition.

    Parameters:
      filepath (str): The path to the forces file. Defaults to 'inputs/forces'.

    Returns:
      Tuple[np.ndarray, int]:
        - padded_forces (np.ndarray): A numpy array containing the force data, padded with an extra row for 1-based indexing.
        - num_force_BCs (int): The number of force boundary conditions read from the first line of the file.
    """
    try:
        # Read the first line to get the number of force boundary conditions
        with open(filepath, 'r') as file:
            num_force_BCs = int(file.readline().strip())
    except FileNotFoundError:
        exit(f"ERROR! File not found at {filepath}")
    except ValueError:
        exit(f"ERROR! First line of file at {filepath} should be an integer.")
    # Read the rest of the file (starting from the second line) using pandas.read_csv with whitespace as the delimiter
    force_file = pd.read_csv(filepath, sep=r'\s+', header=None, skiprows=1)
    # Convert the DataFrame to a numpy array
    forces = force_file.to_numpy()
    # Pad the forces array with an extra row at the beginning (filled with NaN) for 1-based indexing
    padded_forces = np.pad(forces, ((1, 0), (0, 0)), 'constant', constant_values=np.nan)

    return padded_forces, num_force_BCs

def read_displacements_file(filepath: str = 'inputs/displacements') -> Tuple[np.ndarray, int]:
    """
    Reads a displacements file and returns a padded numpy array of displacement data along with the number of displacement boundary conditions.

    The expected file format is:
      - The first line contains an integer indicating the number of displacement boundary conditions.
      - The subsequent lines contain displacement data, where each row corresponds to a displacement entry.

    The function performs the following steps:
      1. Opens the file and reads the first line to extract the number of displacement boundary conditions.
      2. Uses pandas.read_csv to read the rest of the file (skipping the first line) with whitespace as the delimiter.
      3. Converts the read data into a numpy array.
      4. Pads the array by adding an extra row at the beginning (filled with NaN) to support 1-based indexing.

    Parameters:
      filepath (str): The path to the displacements file. Defaults to 'inputs/displacements'.

    Returns:
      Tuple[np.ndarray, int]:
        - padded_displacements (np.ndarray): A numpy array containing the displacement data, padded with an extra row for 1-based indexing.
        - num_displacement_BCs (int): The number of displacement boundary conditions as read from the first line of the file.
    """
    try:
        # Read the first line to get the number of displacement boundary conditions
        with open(filepath, 'r') as file:
            num_displacement_BCs = int(file.readline().strip())
    except FileNotFoundError:
        exit(f"ERROR! File not found at {filepath}")
    except ValueError:
        exit(f"ERROR! First line of file at {filepath} should be an integer.") 
    
    # Read the rest of the file (starting from the second line) using pandas.read_csv with whitespace as the delimiter
    displacement_file = pd.read_csv(filepath, sep=r'\s+', header=None, skiprows=1)
    # Convert the DataFrame to a numpy array
    displacements = displacement_file.to_numpy()
    # Pad the displacements array with an extra row at the beginning (filled with NaN) for 1-based indexing
    padded_displacements = np.pad(displacements, ((1, 0), (0, 0)), 'constant', constant_values=np.nan)

    return padded_displacements, num_displacement_BCs

def reorder_global_connectivity(disp_BCs: np.ndarray, gcon: np.ndarray, num_total_dofs: int) -> np.ndarray:
    """
    Reorders the global connectivity matrix by moving degrees of freedom (DOFs) with prescribed displacement
    boundary conditions to the end of the numbering. This ensures that free (unknown) DOFs are numbered first,
    which is often required for numerical solution procedures.

    The function assumes that:
      - The displacement boundary conditions (disp_BCs) array is padded for 1-based indexing.
      - Each row in disp_BCs (except the first padded row) is in the format: [Node Number, Local DOF, Displacement Value],
        where Node Number and Local DOF are used for reordering.
      - The global connectivity matrix (gcon) is also padded for 1-based indexing, and it maps each node and its local DOFs
        to a unique global DOF number.
      - The total number of DOFs is provided in num_total_dofs.

    The reordering is performed by:
      1. Iterating over each displacement boundary condition (starting from the second row to skip the padding).
      2. Extracting the corresponding node number and local DOF.
      3. Retrieving the current global DOF for the given node and local DOF.
      4. Decreasing the global DOF numbers of all entries greater than the current prescribed DOF by 1.
         This effectively "shifts" free DOFs upward.
      5. Assigning the highest global DOF number (num_total_dofs) to the current prescribed DOF position, thereby moving it to the end.

    Parameters:
      disp_BCs (np.ndarray): A 2D array of displacement boundary conditions, padded for 1-based indexing.
                             Each row (after the first dummy row) should contain [Node Number, Local DOF, Displacement Value].
      gcon (np.ndarray): A 2D global connectivity matrix, padded for 1-based indexing, where each entry corresponds to a global DOF number.
      num_total_dofs (int): The total number of degrees of freedom in the system, NOT equal to number of active equations.

    Returns:
      np.ndarray: The reordered global connectivity matrix with prescribed DOFs moved to the end.
    """
    # Create a copy of the global connectivity matrix to avoid modifying the original
    gcon = gcon.copy()

    # Process each displacement boundary condition (skipping the padded first row)
    for i in range(1, len(disp_BCs)):
        # Each line in disp_BCs is expected to be [Node Number, Local DOF, Displacement Value]
        # Convert Node Number and Local DOF to integers (displacement value is ignored here)
        node_num, local_dof, _ = disp_BCs[i].astype(int)
        # Retrieve the current global DOF for the specified node and local DOF
        curr_BC_global_dof = gcon[node_num, local_dof]
        # Adjust global DOF numbers:
        # For all entries with a DOF number greater than the current prescribed DOF, decrement by 1 to shift free DOFs upward.
        gcon[gcon > curr_BC_global_dof] -= 1
        # Set the prescribed DOF's new global number to the last position (num_total_dofs)
        gcon[node_num, local_dof] = num_total_dofs

    return gcon

def init_forces(force_BCs: np.ndarray, gcon: np.ndarray, num_total_dofs: int) -> np.ndarray:
    """
    Initializes the global force vector based on the specified force boundary conditions.

    This function creates a force vector of size (num_total_dofs + 1) to support 1-based indexing.
    The first element (index 0) is padded with NaN since it is not used. Then, for each force boundary
    condition provided in the force_BCs array, the function:
      1. Extracts the node number, local DOF, and force value.
      2. Casts the node number and local DOF to integers, as they are used as indices.
      3. Uses the global connectivity matrix (gcon) to determine the corresponding global DOF.
      4. Adds the force value to the corresponding entry in the force vector.

    Parameters:
      force_BCs (np.ndarray): A 2D array of force boundary conditions (padded for 1-based indexing), where each row
                              (after the padded row) has the format [Node Number, Local DOF, Force Value].
      gcon (np.ndarray): The global connectivity matrix (padded for 1-based indexing) that maps each node's local DOF to a global DOF.
      num_total_dofs (int): The total number of degrees of freedom in the system.

    Returns:
      np.ndarray: A global force vector of shape (num_total_dofs + 1, 1) with force contributions applied to prescribed DOFs.
                  The first element is NaN as it is used solely for 1-based indexing.
    """
    # Create a force vector initialized to zeros with an extra element for 1-based indexing.
    forces = np.zeros(shape=(num_total_dofs + 1, 1), dtype=float)
    forces[0] = np.nan  # The 0th element is a placeholder for 1-based indexing.
    
    # Process each force boundary condition (skip the padded first row).
    for i in range(1, len(force_BCs)):
        # Each row is expected to be [Node Number, Local DOF, Force Value].
        node_num, local_dof, force_val = force_BCs[i]
        # Cast node number and local DOF to integers (indices) since they may be provided as floats.
        node_num, local_dof = int(node_num), int(local_dof)
        # Retrieve the corresponding global DOF using the global connectivity matrix.
        curr_BC_global_dof = int(gcon[node_num, local_dof])
        # Add the force boundary condition value to the force vector at the global DOF index.
        forces[curr_BC_global_dof] += force_val

    return forces

def build_bele(cosines: np.ndarray, num_elements: int, dof_per_node: int) -> np.ndarray:
    """
    Constructs the BELE matrix for element connectivity using direction cosines.

    The BELE matrix is used to form the transformation of degrees of freedom for elements,
    where each element is associated with two nodes. Each node has a specified number of degrees
    of freedom (dof_per_node). The resulting matrix has dimensions of (num_elements + 1) x (2 * dof_per_node + 1),
    with the extra row and column included to support 1-based indexing.

    The process is as follows:
      1. A zeros matrix 'bele' is created with extra rows and columns for 1-based indexing.
      2. The first row and first column of 'bele' are set to NaN to serve as placeholders.
      3. The input 'cosines' matrix, which is assumed to be padded for 1-based indexing, is trimmed
         to extract the cosine values for each element (rows 1 to num_elements, columns 1 onward).
      4. For each element, the negative of the cosine values is assigned to the first half of the row
         (corresponding to the first node) and the positive values to the second half (corresponding to the second node).
      5. The completed BELE matrix is returned.

    Parameters:
      cosines (np.ndarray): A 2D numpy array of direction cosines for each element, padded for 1-based indexing.
      num_elements (int): The total number of elements.
      dof_per_node (int): The number of degrees of freedom per node.

    Returns:
      np.ndarray: The BELE matrix of shape (num_elements + 1, 2 * dof_per_node + 1) with 1-based indexing,
                  where each row (starting from index 1) contains the negative and positive cosine values
                  for the corresponding element.
    """
    # Create a BELE matrix initialized with zeros, with extra rows and columns for 1-based indexing.
    bele = np.zeros(shape=(num_elements + 1, 2 * dof_per_node + 1), dtype=float)
    # Set the first row and first column to NaN to maintain 1-based indexing.
    bele[0, 0:] = bele[0:, 0] = np.nan
    # Extract element cosines (ignoring the padded first row and column in the cosines matrix)
    element_cosines = cosines[1:num_elements + 1, 1:]
    # For each element, assign negative cosines for the first node and positive cosines for the second node.
    bele[1:num_elements + 1, 1:] = np.hstack([-element_cosines, element_cosines])
    
    return bele

def create_known_displacements_matrix(displacements: np.ndarray, num_disp_BCs: int, num_nodes: int, dof_per_node: int) -> np.ndarray:
    """
    Creates a matrix of known (prescribed) displacements from the displacement boundary conditions.

    This function constructs a matrix where each entry corresponds to a prescribed displacement value
    for a given node and its local degree of freedom (DOF). The matrix dimensions are (num_nodes + 1) x (dof_per_node + 1),
    with an extra row and column to facilitate 1-based indexing (the 0th row and 0th column are placeholders).

    Parameters:
      displacements (np.ndarray): A 2D array of displacement boundary conditions, padded for 1-based indexing.
                                  Each row (after the dummy first row) is expected to have the format:
                                  [node number, local DOF, prescribed displacement value].
      num_disp_BCs (int): The number of displacement boundary conditions (excluding the padded row).
      num_nodes (int): The total number of nodes in the system (excluding the padded row).
      dof_per_node (int): The number of degrees of freedom per node.

    Returns:
      np.ndarray: A matrix of shape (num_nodes + 1, dof_per_node + 1) where each entry represents
                  the prescribed displacement for the corresponding node and DOF. Entries with no prescribed
                  displacement remain 0.
    """
    # Initialize the known displacements matrix with zeros, including an extra row and column for 1-based indexing.
    known_displacements = np.zeros((num_nodes + 1, dof_per_node + 1))
    # Populate the known displacements matrix using the displacement boundary conditions.
    for i in range(1, num_disp_BCs + 1):
        node = int(displacements[i, 0])   # Node number from displacement BC
        dof  = int(displacements[i, 1])   # Local DOF number from displacement BC
        value = displacements[i, 2]       # Prescribed displacement value
        known_displacements[node, dof] = value
        # So, for node i, the row looks like: 
        # [NaN, prescribed value for DOF 1, prescribed value for DOF 2, ...]
    return known_displacements

def assemble_element_by_element(bele: np.ndarray, elenodes: np.ndarray, gcon: np.ndarray, displacements: np.ndarray, forces: np.ndarray, 
                                E: np.ndarray, A: np.ndarray, L: np.ndarray, dof_per_node: int, num_active_dofs: int, num_disp_BCs: int, num_nodes: int) -> Tuple[np.ndarray, np.ndarray]:
    """
    Assemble the global stiffness matrix and adjust the force vector using an element-by-element approach.

    This function computes the global stiffness matrix for a finite element model by assembling each element's 
    local stiffness matrix into the overall global system. It also adjusts the global force vector to account 
    for prescribed displacement boundary conditions by transferring the contributions (K_up * u_prescribed) 
    from the stiffness matrix to the force vector.

    The assembly process involves:
      1. Creating a reduced force vector and global stiffness matrix for the free DOFs.
      2. Constructing a matrix of known (prescribed) displacements from the displacement BC array.
      3. For each element:
         a. Computing its local stiffness matrix using the transformation factors (bele), Young's modulus (E),
            cross-sectional area (A), and element length (L).
         b. Mapping the local stiffness contributions into the global stiffness matrix using the element connectivity
            (elenodes) and global connectivity (gcon) matrices.
         c. For DOFs associated with prescribed displacements, subtracting the contribution (K_up * u_prescribed)
            from the force vector.

    Parameters:
      bele (np.ndarray): Transformation factors (direction cosines) for each element, padded for 1-based indexing.
      elenodes (np.ndarray): Connectivity array mapping each element to its nodes (1-based indexing).
      gcon (np.ndarray): Global connectivity matrix mapping each node’s local DOFs to global DOF numbering (1-based indexing).
      displacements (np.ndarray): Displacement boundary condition array (padded for 1-based indexing). 
                                  Each row is of the form [node number, local DOF, prescribed displacement value].
      forces (np.ndarray): Global force vector (external loads), padded for 1-based indexing.
      E (np.ndarray): Array of Young's modulus values for each element.
      A (np.ndarray): Array of cross-sectional area values for each element.
      L (np.ndarray): Array of lengths for each element.
      dof_per_node (int): Number of degrees of freedom per node (e.g., 2 for a 2D truss).
      num_total_dofs (int): Total number of degrees of freedom in the original (full) global system.
      num_disp_BCs (int): Number of prescribed displacement boundary conditions (excluding padding).
      num_nodes (int): Total number of nodes in the system (excluding padding).

    Returns:
      Tuple[np.ndarray, np.ndarray]:
         - reduced_global_stiffness (np.ndarray): The assembled and reduced global stiffness matrix corresponding to the free DOFs, 
           using 1-based indexing.
         - reduced_forces (np.ndarray): The adjusted force vector after transferring the contributions of prescribed displacements,
           using 1-based indexing.

    Notes:
      - All input arrays are assumed to be padded for 1-based indexing (i.e., index 0 is a dummy row/column).
      - The prescribed displacement contributions (K_up * u_prescribed) are removed from the stiffness system and included 
        in the force vector to form a reduced system for free DOFs.
      - Ensure that all input arrays have compatible dimensions as expected by the finite element model.
    """

    # Create a reduced force vector for the free DOFs (preserving 1-based indexing; index 0 is a dummy).
    reduced_forces = forces.copy()[0:num_active_dofs+1]
    # Initialize the reduced global stiffness matrix for free DOFs.
    stiff_size = num_active_dofs + 1  # extra "+1" for 1-based indexing
    reduced_global_stiff = np.zeros((stiff_size, stiff_size), dtype=float)
    # Build a matrix for known (prescribed) displacements from the displacement BCs.
    known_displacements = create_known_displacements_matrix(displacements, num_disp_BCs, num_nodes, dof_per_node)

    # Loop over each element (starting at index 1 due to 1-based indexing).
    for element_i in range(1, len(elenodes)):
        # Initialize the local stiffness matrix for the current element.
        # The size is (2*dof_per_node)x(2*dof_per_node) for 2 nodes per element with an extra row and column for 1-based indexing.
        local_stiffness = np.zeros((2 * dof_per_node + 1, 2 * dof_per_node + 1), dtype=float)
        
        # Compute the local stiffness matrix.
        # Formula: kele[i, j] = (E*A/L) * (bele for DOF i) * (bele for DOF j)
        # NOTE: we are creating the local K matrix, where it's comprised of all possible combinations of c1, c2, -c1, -c2.
        local_stiffness[1:, 1:] = E[element_i] * A[element_i] / L[element_i] * np.outer(bele[element_i, 1:], bele[element_i, 1:])
        
        # Assemble the LOCAL stiffness contributions into the GLOBAL stiffness matrix.
        # NOTE: K_ele's row/col architecture:
                  # 1st half is for node1 and the 2nd half is for node2,
                  # and each node has dof_per_node (2 or 3) degrees of freedom.
        
        # NOTE: We go Rows first
        for node_i in [1, 2]: # Loop over the two NODES of the element.
          for node_dof_i in range(1, dof_per_node + 1): # Loop over each LOCAL dof for the current node.
                # get the LOCAL ROW index in the element's stiffness matrix.
                # we are accessing each ROW of K_ele based on node# and local dof#
                dof_i_local = (node_i - 1) * dof_per_node + node_dof_i # essentially the area of a rectangle
                
                # get the node number local node (1 or 2) for current element
                local_node_num_i = int(elenodes[element_i, node_i])
                # Map the LOCAL node and DOF to the GLOBAL DOF using the global connectivity matrix.
                dof_i_global = int(gcon[local_node_num_i, node_dof_i])
                
                # Assemble only if the global DOF is free / active equation.
                # we don't care about equatiosn that are associated with prescribed displacements. 
                if dof_i_global <= num_active_dofs:
                    # NOTE: now we do the same thing for the COLUMNS, but note that removing columns requires MOVING known values to the RHS
                    for node_j in [1, 2]: # Loop over the two nodes (columns) of the element.
                        for node_dof_j in range(1, dof_per_node + 1):
                            # Calculate the local column index in the element's stiffness matrix.
                            dof_j_local = (node_j - 1) * dof_per_node + node_dof_j

                            # get the node number local node (1 or 2) for current element
                            local_node_num_j = int(elenodes[element_i, node_j])
                            # Map the local DOF to the corresponding global DOF.
                            dof_j_global = int(gcon[local_node_num_j, node_dof_j])
                            
                            # again, check if the column is for corresponding free row.
                            if dof_j_global <= num_active_dofs:
                                # For FREE/ACTIVE DOFs, add the local stiffness contribution to the global stiffness matrix.
                                reduced_global_stiff[dof_i_global, dof_j_global] += local_stiffness[dof_i_local, dof_j_local]
                            # if NOT, move columns that are beyond active number of equations, to the RHS
                            else:
                                # For prescribed DOFs, adjust the force vector by subtracting the contribution 
                                u = known_displacements[local_node_num_j, node_dof_j]
                                reduced_forces[dof_i_global] -= local_stiffness[dof_i_local, dof_j_local] * u
          
    return reduced_global_stiff, reduced_forces


def solve_reduced_nodal_displacements(reduced_stiffness: np.ndarray, RHS_reduced: np.ndarray):
    """
    Solves for the unknown nodal displacements in a reduced finite element system.

    This function takes the reduced global stiffness matrix (after removing prescribed DOFs)
    and the corresponding reduced force vector (RHS) to solve for the unknown nodal displacements.

    Parameters:
      reduced_stiffness : np.ndarray
          The reduced global stiffness matrix after eliminating constrained DOFs.
      RHS_reduced : np.ndarray
          The reduced force vector after applying prescribed displacement boundary conditions.

    Returns:
      np.ndarray
          A 1D array containing the computed unknown nodal displacements for free DOFs.
    """
    # Extract the actual stiffness matrix and RHS vector by removing the first row and column.
    # These first entries are dummy values for 1-based indexing and do not affect the solution.
    return np.linalg.solve(reduced_stiffness[1:, 1:], RHS_reduced[1:]) 

def insert_solved_displacements(full_disp: np.ndarray, solved_disp: np.ndarray, gcon: np.ndarray, num_active_dofs: int) -> np.ndarray:
    """
    Inserts the computed displacements of free (active) DOFs into the full nodal displacement matrix.

    This function updates the full nodal displacement matrix by filling in the solved displacement values 
    for the active DOFs while preserving the prescribed (fixed) displacement values.

    Parameters:
      full_disp : np.ndarray
          The full nodal displacement array where all DOFs (free and prescribed) are stored.
      solved_disp : np.ndarray
          The computed displacements of free DOFs obtained from solving the reduced system.
      gcon : np.ndarray
          The global connectivity matrix mapping local node DOFs to global DOF numbers.
      num_active_dofs : int
          The total number of active (free) DOFs in the system.
      num_nodes : int
          The total number of nodes in the structure.
      dof_per_node : int
          The number of degrees of freedom per node.

    Returns:
      np.ndarray
          The updated full displacement array (matrix) with solved free DOFs filled in.

    Notes:
      - Only active DOFs (those that were not prescribed) are updated with solved values.
      - Prescribed DOFs (displacement boundary conditions) remain unchanged.
    """
    # Flatten the global connectivity matrix to get a 1D array of global DOF indices
    flat_gcon = gcon.flatten()
    # Create a boolean mask that identifies free (active) DOFs:
    # because we only need to fill in solved displacements, we already have prescribed displacements in our matrix.
    # A DOF is free if its global index is <= num_active_dofs.
    free_dofs_mask = flat_gcon <= num_active_dofs
    # Flatten the full displacement matrix so we can update it using 1D indexing
    flat_full_disp = full_disp.flatten()
    # For free DOFs, update the displacement values with the solved values.
    flat_full_disp[free_dofs_mask] = solved_disp[flat_gcon[free_dofs_mask].astype(int)]

    # Reshape the updated displacement array back to its original matrix form
    return flat_full_disp.reshape(full_disp.shape)


def write_nodal_displacements_file(nodes:np.ndarray, nodal_disp: np.ndarray, num_nodes:int, dof_per_node: int) -> pd.DataFrame:
    # pull out x and y coordinates of each node to form full data table
    data = np.hstack([nodes[1:, 1:], nodal_disp[1:, 1:]]) # Skip the 0th row/col for 1-based indexing

    # Construct the DataFrame
    df = pd.DataFrame(
        data=data,
        columns=['x', 'y', 'z', 'u', 'v', 'w'] if dof_per_node == 3 else ['x', 'y','u', 'v'],
        index=np.arange(1, num_nodes+1)
    )
    # Set the index name explicitly
    df.index.name = 'Node #'

    return df.round(6)

def write_external_forces_file(nodes:np.ndarray, ext_forces: np.ndarray, num_nodes:int, dof_per_node: int) -> pd.DataFrame:
    # pull out x and y coordinates of each node to form full data table
    data = np.hstack([nodes[1:, 1:],ext_forces[1:, 1:]]) # Skip the 0th row/col for 1-based indexing

    # Construct the DataFrame
    df = pd.DataFrame(
        data=data,
        columns=['x', 'y', 'z', 'f_x', 'f_y', 'f_w'] if dof_per_node == 3 else ['x', 'y','f_x', 'f_y'],
        index=np.arange(1, num_nodes+1)
    )
    # Set the index name explicitly
    df.index.name = 'Node #'

    return df.round(6)

def write_bar_properties_file(strain:np.ndarray, bar_force:np.ndarray, L:np.ndarray, num_elements:int) -> pd.DataFrame:
    # reshape all vectors to N by 1 matrix
    # Reshape arrays to column vectors (in-place)
    strain = strain.reshape((len(strain), 1))
    bar_force = bar_force.reshape((len(bar_force), 1))
    L = L.reshape((len(L), 1))
    # pull out x and y coordinates of each node to form full data table
    data = np.hstack([strain[1:, :], bar_force[1:, :], L[1:, :]]) # Skip the 0th row/col for 1-based indexing

    # Construct the DataFrame
    df = pd.DataFrame(
        data=data,
        columns=['strain', 'bar force', 'bar length'],
        index=np.arange(1, num_elements+1)
    )
    # Set the index name explicitly
    df.index.name = 'Element #'

    return df.round(6)

def main():
    """
    Main function to execute the finite element analysis for a 3D truss system.

    This function:
    - Reads input files containing node coordinates, element connectivity, applied forces, and displacement boundary conditions.
    - Computes degrees of freedom (DOFs) per node and initializes the global DOF structure.
    - Assembles the global stiffness matrix and force vector using an element-by-element approach.
    - Solves for the reduced nodal displacements.
    """

    # Define the directory containing the input files
    directory_path = "/Users/kis/Desktop/COE321K/hw4/test_cases_3d/"
    print(f"ACCESSING FOLDER: {directory_path}")

    # -------------------------------
    # STEP 1: READ NODE INFORMATION
    # -------------------------------
    # Read the node file to obtain nodal coordinates, total number of nodes, and problem dimension (2D/3D)
    nodes, num_nodes, num_dims = read_nodes_file(filepath=directory_path + 'nodes')

    # Compute the degrees of freedom per node (for a truss, DOFs = spatial dimensions)
    dof_per_node = num_dims  

    # Compute the total number of DOFs in the structure (excluding padding)
    num_total_dofs = (len(nodes) - 1) * dof_per_node  # Using 1-based indexing

    # Construct the global connectivity matrix, mapping local DOFs to global indices
    global_connectivity = build_global_connectivity(nodes, dof_per_node)

    # -------------------------------
    # STEP 2: READ ELEMENT CONNECTIVITY
    # -------------------------------
    # Read the element file, which defines how nodes are connected to form elements
    elements, elenodes, num_elements = read_elements_file(filepath=directory_path + 'elements')

    # Compute element lengths and directional cosines (used for transformation matrices)
    Ls, cosines = compute_lengths_and_cosines(elements, nodes)

    # -------------------------------
    # STEP 3: READ FORCE AND DISPLACEMENT BOUNDARY CONDITIONS
    # -------------------------------
    # Read the applied force boundary conditions (external loads)
    force_BCs, num_force_BCs = read_forces_file(filepath=directory_path + 'forces')

    # Read the prescribed displacement boundary conditions (fixed DOFs)
    disp_BCs, num_disp_BCs = read_displacements_file(filepath=directory_path + 'displacements')

    # Compute the number of active DOFs (free DOFs without prescribed displacements)
    num_active_dofs = num_total_dofs - num_disp_BCs

    # Reorder the global connectivity matrix to ensure proper handling of prescribed displacements
    global_connectivity = reorder_global_connectivity(disp_BCs, global_connectivity, num_total_dofs)

    # Initialize the global force vector, incorporating external loads
    forces = init_forces(force_BCs, global_connectivity, num_total_dofs)

    # -------------------------------
    # STEP 4: ASSEMBLE GLOBAL STIFFNESS MATRIX
    # -------------------------------
    # Construct element transformation matrices (direction cosines for each bar element)
    bar_elements = build_bele(cosines, num_elements, dof_per_node)

    # Extract Young's modulus (E) and cross-sectional area (A) from element properties
    Es = elements[:, -2]  # Young's modulus for each element
    As = elements[:, -1]  # Cross-sectional area for each element

    # Assemble the global stiffness matrix and reduce it for active DOFs
    K_red, F_red = assemble_element_by_element(
        bar_elements, elenodes, global_connectivity, disp_BCs, forces, 
        Es, As, Ls, dof_per_node, num_active_dofs, num_disp_BCs, num_nodes
    )

    # -------------------------------
    # STEP 5: SOLVE FOR NODAL DISPLACEMENTS
    # -------------------------------
    # Solve for the UNKNOWN nodal displacements using the reduced system of equations.
    # This function solves K_reduced * u_free/unknown = F_reduced for the free DOFs.
    solved_U_red = solve_reduced_nodal_displacements(K_red, F_red)

    # Reconstruct the full nodal displacement matrix by incorporating known (prescribed) displacements.
    # This ensures that both free and fixed displacements are included in the final displacement array.
    nodal_disps = create_known_displacements_matrix(disp_BCs, num_disp_BCs, num_nodes, dof_per_node)

    # Pad the solution with a NaN value at the front to maintain 1-based indexing.
    # This aligns the array structure with the 1-based convention used in input data.
    solved_U_red = np.pad(solved_U_red, ((1,0), (0,0)), 'constant', constant_values=np.nan).reshape((len(solved_U_red)+1,))

    nodal_disps = insert_solved_displacements(nodal_disps, solved_U_red, global_connectivity, num_active_dofs)

    stretch = np.zeros(shape=(num_elements+1,))
    bar_forces = np.full_like(stretch, fill_value=np.nan)
    external_forces = np.zeros((num_nodes+1, dof_per_node+1))

    stretch[0] = np.nan

    for iele in range(1, num_elements+1): # Loop over each element
        ulocal = np.zeros((2*dof_per_node+1,)) # Initialize local displacement vector
        ulocal[0] = np.nan # Set the 0th index to NaN for 1-based indexing
        for local_node in [1,2]: # Loop over the two nodes of the element
            for local_dof in range(1, dof_per_node+1): # Loop over each local DOF for the current node
                # Get the global node number for the current local node
                ulocal[dof_per_node * (local_node - 1)+local_dof] = nodal_disps[int(elenodes[iele, local_node]), local_dof]
        
        for i in range(1, 2*dof_per_node+1): # Loop over each local DOF of the element
            stretch[iele] += bar_elements[iele, i] * ulocal[i] # Compute the element stretch
        
        bar_forces[iele] = stretch[iele] * Es[iele] * As[iele] / Ls[iele] # Compute the bar force
        
        for local_node in [1, 2]: # Loop over the two nodes of the element
            for local_dof in range(1, dof_per_node+1): # Loop over each local DOF for the current node
                global_node = int(elenodes[iele, local_node]) # Get the global node number
                # Update the external forces array with the computed forces
                external_forces[global_node, local_dof] += bar_forces[iele] * bar_elements[iele, dof_per_node * (local_node - 1) + local_dof]

    # Compute the strains in each element
    strains = stretch / Ls
    
    #### print out final data outputs:
    print("\n")
    print("-" * 40)
    nodal_displacements_df = write_nodal_displacements_file(nodes, nodal_disps, num_nodes, dof_per_node)
    print("<<< NODAL DISPLACEMENTS DATA TABLE >>>")
    print(nodal_displacements_df)
    external_forces_df = write_external_forces_file(nodes, external_forces, num_nodes, dof_per_node)
    print("\n<<< EXTERNAL FORCES DATA TABLE >>>")
    print(external_forces_df)
    element_properties_df = write_bar_properties_file(strains, bar_forces, Ls, num_elements)
    print("\n<<< ELEMENT STRAINS AND FORCES DATA TABLE >>>")
    print(element_properties_df)

if __name__ == "__main__":
    main()